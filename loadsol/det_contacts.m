function [con, off, without_zeros] = det_contacts(loadstruct, sensor, varargin);    %outputvalue 'without_zeros' is anly possible if 'transmission_error'-input is specified as 1 or 2  sens{1,1} = sensor; % sensorname to be analyzed    data = loadstruct.(sens{1,1}); % data of sensorname  if sensor(1) == 'R'; %time of R or L sensor    time = loadstruct.R_time;  elseif sensor(1) == 'L';    time = loadstruct.L_time;  else    error ("check sensorname: L or R must be given as first char");  end
    con_th    = 30; %default values in N  off_th    = 30;  min_cyc   = 200;  %default values in ms  max_cyc   = 3000;  trans     = 0; %trans 0 = transmission error is not taken into account    while (numel(varargin)>0) %changes values from default to specified input values: *'inputname', value*    switch (varargin{end-1})      case 'con_th'        con_th = varargin{end};        varargin(end-1:end) = [];      case 'off_th'        off_th = varargin{end};        varargin(end-1:end) = [];      case 'min_cycle'        min_cyc = varargin{end};        varargin(end-1:end) = [];      case 'max_cycle'        max_cyc = varargin{end};        varargin(end-1:end) = [];      case 'gen_th' %general threshold        con_th = varargin{end};        off_th = varargin{end};        varargin(end-1:end) = [];      case 'transmission_error' %optional input: transmission error: how to deal with it.        trans = varargin{end};  % possible options: 0 = no changes in data; 1 = all zeros are interpolated linearly; 2 = only zeros that border on values > th are interpolated linearly;        varargin(end-1:end) = [];      case 'cycle_th' %optinal input: cycle_th: is only detected as a cycle if the max value of the cycle is > input value        cycle_th = varargin{end};        varargin(end-1:end) = [];      otherwise        error ("check input arguments");    end%switch  end%while  msperF = (time(2) - time(1))*1000; %miliseconds/Frame  min_ms = min_cyc/msperF; max_ms = max_cyc/msperF; %number of idx (frames) for min and max cycle length    if con_th<off_th %takes lower th as th to collect first values    th = con_th;  else     th = off_th;  end%if      if trans > 0; %if transmission error is specified as 1 or 2    without_zeros = data;    zero = find(~data); %finds index of zero values in data    nr_zero = length(zero);    row = 1; col = 1;    for zer = 1:nr_zero %resorts in a zeromatrix, so that indexes next to each other are in the same row      if zer == 1        zermat(row,col) = zero(zer);
      elseif zero(zer) - zero(zer-1) == 1        col = col+1;        zermat(row,col) = zero(zer);      else        col = 1;        row = row+1;        zermat(row,col) = zero(zer);      end%if
    end%for    if exist('zermat');    nr_rows = rows(zermat);    for row = 1:nr_rows %for each punch of zeros which are next to each other      rowstore = nonzeros(zermat(row,:)); %indexes of zeros (without zero --> due to matrix length)      s = rowstore(1); %first idx of row      e = rowstore(end); %last idx of row      if s!= 1 && e != length(data) %if first idx is unequal to 1 and last index is unequal to number of data        predat = data(s-1); %datavalue one prior s-index        postdat= data(e+1); %datavalue one after e-index        if trans == 1 %'transmission error' = 1          dif = postdat-predat; %difference between bordered values          framedif = round((dif/(length(rowstore)+1))*100)/100; %difference of each frame with zeros in between the bordered values          for col = 1:length(rowstore);            without_zeros(rowstore(col)) = without_zeros(rowstore(col)-1)+framedif; %interpolation
          end%for        elseif trans == 2 %'transmission error' = 2          if predat > th || postdat > th; %same as if trans = 1, but only if one of the border values is greater than th            dif = postdat-predat;            framedif = round((dif/(length(rowstore)+1))*100)/100;            for col = 1:length(rowstore);              without_zeros(rowstore(col)) = without_zeros(rowstore(col)-1)+framedif;             end%for
          end%if
        end%if      elseif s == 1 %if first zero value has idx 1        postdat= data(e+1); %same thing done but only for right border        if trans == 1          for col = 1:length(rowstore);            without_zeros(rowstore(col)) = postdat;           end%for        elseif trans == 2 && postdat > th          for col = 1:length(rowstore);            without_zeros(rowstore(col)) = postdat;           end%for        end%if      elseif e == length(data) %if last zero value has idx length(data)        predat = data(s-1); %same thing done but only for left border        if trans == 1          for col = 1:length(rowstore);            without_zeros(rowstore(col)) = predat;           end%for        elseif trans == 2 && predat > th          for col = 1:length(rowstore);            without_zeros(rowstore(col)) = predat;           end%for        end%if
        
      end%if
    end%for    end%if    data = without_zeros; %new data for the analyzis is without zeros
  end%if
  
  thidx1 = find(data>th); %finds idx of all values > th   if length(thidx1)>0; %execute the following just when values > th exist  a = 1; b = 1; %a = row; b = column  for id = 1:length(thidx1) %sorts idx with each cycle with values > th in rows    throws(a,b) = thidx1(id);     b = b+1;    if id < length(thidx1);    if thidx1(id+1)-thidx1(id) > 1      a = a+1;      b = 1;
     end%if     end%if
   end%for      [row, col] = size(throws);   for ro = 1:row %collects first and last idxvalue of each row (cycle)     datrow = nonzeros(throws(ro,:));     thcyc(ro,1) = datrow(1);     thcyc(ro,2) = datrow(end);
   end%for      for ro = 1:row     if con_th>th       contacts = find(data(thcyc(ro,1):end)>con_th); %find index of data > con_th in data from con based on th till end       if length(contacts)<1 % if no value is in this data area: idx = 1         contacts = 1;       end%if
       thcyc(ro,1) = contacts(1)+thcyc(ro,1)-1; % con idx = idx of whole data      elseif off_th>th       contacts = find(data(1:thcyc(ro,2))>off_th); %find index of data > off_th in data from first till off based on th       if length(contacts)<1 % if no value is in this data area: idx = 1         contacts = 1;       end%if       thcyc(ro,2) = contacts(end); %idx in the dataset for off_th     end%if
   end%for end%if  if exist('thcyc') == 1; %only execute the following if thcyc exists   cy = 1;   for ro = 1:row     if thcyc(ro,1)<=thcyc(ro,2) && abs(thcyc(ro,1)-thcyc(ro,2))<max_ms && abs(thcyc(ro,1)-thcyc(ro,2))> min_ms %is a cycle if con<off & duration of cycle < maximum and > minimum cycle duration       cycleidx(cy,:) = thcyc(ro,:);       cy=cy+1; 
     end%if     
   end%for   if exist('cycle_th')==1 && exist('cycleidx')==1 %if varargin cycle_th is given and cycles exist due to previous conditions--> rund this selection     cy = 1;      for ro = 1:rows(cycleidx);          dat = data(cycleidx(ro,1):cycleidx(ro,2)); %values of data of the cycle          if max(dat)> cycle_th %max value has to be greater than cycle_th to be considered as cycle            cycleidxreal(cy,:) = cycleidx(ro,:);            cy=cy+1;           end%if
      end%for      cycleidx = cycleidxreal;
   end%if        if exist('cycleidx') == 1;  % only execute the following when there are cycles    cycle(:,1) = time(cycleidx(:,1)); %gets times of idx
    cycle(:,2) = time(cycleidx(:,2));       con = cycle(:,1)'; con = con((con>time(1)) == 1); %contact times; if first value > th is the first value in general this gets excluded because there might be values > th before the first frameoff = cycle(:,2)'; off = off((off<time(end)) == 1); %off times; if last value> th is the last value in general this gets excluded    else %no cycle      disp('No cycle with this requirements')      con = []; off = [];    end%if else %no cycle  disp('No cycle with this requirements')  con = []; off = []; end%ifend%function